% interactcadsample.tex
% v1.03 - April 2017

\documentclass[]{interact}

\usepackage{epstopdf}% To incorporate .eps illustrations using PDFLaTeX, etc.
\usepackage{subfigure}% Support for small, `sub' figures and tables
%\usepackage[nolists,tablesfirst]{endfloat}% To `separate' figures and tables from text if required

\usepackage{natbib}% Citation support using natbib.sty
\bibpunct[, ]{(}{)}{;}{a}{}{,}% Citation support using natbib.sty
\renewcommand\bibfont{\fontsize{10}{12}\selectfont}% Bibliography support using natbib.sty

\theoremstyle{plain}% Theorem-like structures provided by amsthm.sty
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}

\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{notation}{Notation}


% tightlist command for lists without linebreak
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\def\tightlist{}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{nicematrix}
\NiceMatrixOptions{code-for-first-row = \color{red} ,code-for-last-row = \color{red} ,code-for-first-col = \color{blue} ,code-for-last-col = \color{blue}}


\begin{document}


\articletype{Short Technical Note}

\title{Appendix: New and simplified manual controls for projection and
slice tours}


\author{\name{Ursula Laa$^{a}$, Alex Aumann$^{b}$, Dianne
Cook$^{c}$, German Valencia$^{b}$}
\affil{$^{a}$Institute of Statistics, University of Natural Resources
and Life Sciences, Vienna; $^{b}$School of Physics and Astronomy, Monash
University; $^{c}$Department of Econometrics and Business Statistics,
Monash University}
}

\thanks{CONTACT Ursula
Laa. Email: \href{mailto:ursula.laa@boku.ac.at}{\nolinkurl{ursula.laa@boku.ac.at}}, Alex
Aumann. Email: \href{mailto:aaum0002@student.monash.edu}{\nolinkurl{aaum0002@student.monash.edu}}, Dianne
Cook. Email: \href{mailto:dicook@monash.edu}{\nolinkurl{dicook@monash.edu}}, German
Valencia. Email: \href{mailto:german.valencia@monash.edu}{\nolinkurl{german.valencia@monash.edu}}}

\maketitle


\begin{keywords}
data visualisation; grand tour; statistical computing; statistical
graphics; multivariate data; dynamic graphics
\end{keywords}

\hypertarget{refinements-to-enforce-exact-position}{%
\section{Refinements to enforce exact
position}\label{refinements-to-enforce-exact-position}}

The problem with new simple method (Algorithm 1) is that the precise
values for \(V_m\) cannot be specified because the orthonormalisation
will change them.

\hypertarget{adjustment-method-1}{%
\subsection{Adjustment method 1}\label{adjustment-method-1}}

A small modification to algorithm 1 will maintain the components of
\(V_m\) precisely (Figure \ref{fig:othermethod}. It is as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Provide \(A\), and \(m\).
\item
  Change values in row \(m\), giving \(A^*\).
\item
  Store row \(m\) separately, and zero the values of row \(m\) in
  \(A^*\), giving \(A^{*0}\).
\item
  Orthonormalise \(A^{*0}\), using Gram-Schmidt.
\item
  Replace row \(m\) with the original values, giving \(A^{**}\).
\item
  For \(d=2\), adjust the values of \({\boldmath a}^{**}_{.2}\) using
\end{enumerate}

\[a^{**}_{j2}+\frac{a_{m1}a_{m2}}{p-1}, j=1, ..., p, j\neq m\].

which ensures that

\[\sum_{j=1, j\neq m}^p a^{**}_{j1}a^{**}_{j2} + a_{m1}a_{m2} = 0\].

If \(d>2\) the process would be sequentially repeated in the same manner
that Gram-Schmidt is applied sequentially to orthormalise the columns of
a matrix. If \(d=1\) no orthonormalisation is needed, and the projection
vector would simply need to be normalized after each adjustment.

\begin{figure}
\includegraphics[width=1\linewidth]{appendix_files/figure-latex/othermethod-1} \caption{Manual controls with algorithm 2. The precise location of the axis is maintained.}\label{fig:othermethod}
\end{figure}

\hypertarget{adjustment-method-2}{%
\subsection{Adjustment method 2}\label{adjustment-method-2}}

For \(d=2\) projections, the projection matrix is the sub-matrix of
\(A\) formed by its first two columns. Whereas orthonormality of the
basis for the p-dimensional space is given by
\(e_i\cdot e_j=\delta_{ij},{i,j,=1,\cdots,}\), orthonormality of the
projection matrix is expressed as
\(P_i\cdot P_j=\delta_{ij}, {i,j=1,2}\). Movement of the cursor takes
the two components \({x_{m1},x_{m2}}\) into a selected new value
\({a,b}\). Although the motion is constrained by \(a^2+b^2\leq 1\), this
is not sufficient to guarantee orthonormality of the new projection
matrix. One possible algorithm to achieve this is

\begin{enumerate}
\item Cursor movement takes ${x_{m1},x_{m2}}\to {a,b}$
\item The freedom to change the components $A_{i3}\cdots A_{ip}$ (the columns of $A$ not corresponding to the projection matrix) is used to select a new orthonormal basis as follows:
\begin{enumerate}
\item For row $m$ one chooses $A_{m3}=\sqrt{1-a^2-b^2},~A_{m,k>3}=0$
\item For other rows, $A_{i\neq m,j\geq3}$ random selections in the range $(-1,1)$ are made.
\item The Gram-Schmidt algorithm is then used to obtain an orthonormal basis taking $e_m$ as the first vector (which is already normalized), and then proceeding as usual $e_1\to e_1-(e_1\cdot e_m) e_m$, $e_1\to e_1/(e_1\cdot e_1)$, etc.
\end{enumerate}
\item this results in the orthonormal basis $A^*$ and a new projection matrix with $P_{m1}=a,~P_{m2}=b$.
\end{enumerate}

The random completion of \(A\) outside the projection matrix provides an
exploration of dimensions orthogonal to the projection plane. However,
it renders projections in a way that is not continuouns and may be
distracting. This can be alleviated by replacing the random completion
with a rule restricting the size of the jumps.

\begin{align}
A=~~~& \begin{pNiceArray}{ccccc}[first-row,first-col]
\CodeBefore
       \columncolor{red!15}{1,2}
              \rowcolor{blue!15}{4}
     \Body
       & \stackrel{P_1}{\downarrow} & \stackrel{P_2}{\downarrow} &  & &\\
e_1\to & x_{11} & x_{12}  & x_{13} & \cdots & x_{1p} \\
e_2 \to& x_{21}  & x_{22}  & \cdot  &\cdots & x_{2p} \\
\vdots ~~~&\vdots & \vdots  & \vdots & \ddots & \vdots \\ 
 e_m \to& x_{m1}  & x_{m2}  & \cdot  &\cdots & x_{mp} \\   
\vdots ~~~&\vdots & \vdots  & \vdots & \ddots & \vdots \\
e_p \to&x_{p1} & x_{p2} &\cdot &\cdots & x_{pp} 
\end{pNiceArray},\quad (x_{m1},x_{m2})\to (a,b)
\end{align}

\hypertarget{adjustment-method-3}{%
\subsection{Adjustment method 3}\label{adjustment-method-3}}

A very simple adjustment method works purely within the (hyper)plane,
and is using the fact that the first direction will not be rotated when
applying Gram-Schmidt. The following steps are needed:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Provide \(A\), and \(m\).
\item
  Change values in row \(m\), giving \(A^*\).
\item
  Rotate the basis within the projection (hyper-)plane, such that the
  first direction is aligned with the direction of \(m\) in \(A^*\),
  giving \(\hat A^*\). In a 2D projection this means finding the angle
  \(\theta\) by which the basis should be rotated.
\item
  Normalise the first direction in \(\hat A^*\) while keeping the
  contribution in row \(m\) fixed, giving \(\hat A^{*0}\).
\item
  Orthonormalise \(\hat A^{*0}\) using Gram-Schmidt, giving
  \(\hat A^{**}\). By construction the contribution of \(m\) will remain
  fixed.
\item
  Rotate \(\hat A^{**}\) back into the original basis to obtain
  \(A^{**}\).
\end{enumerate}

Diagram needed?

\{\textcolor{blue} Do we need three methods? is this one implemented
somewhere?\}

\hypertarget{software-details}{%
\section{Software details}\label{software-details}}

\begin{itemize}
\tightlist
\item
  \textbf{Why is this a good sandbox}
\item
  \textbf{Explain the functionality available in the notebooks}
\end{itemize}

Here we describe the functions implemented in the Mathematica package
\texttt{mmtour.wl}. The main function is

\begin{itemize}
\item
  \texttt{SliceDynamic{[}data,\ projmat,\ height,\ heightRange,\ legendQ(=1),\ flagQ(=1),\ colorFunc(=ColorData{[}97{]}){]}}
  with arguments
\item
  \texttt{data}: A data matrix with an extra grouping that has a label
  (string) and a flag (numerical)
\item
  \texttt{projmat}: The initial projection matrix. It is possible to
  start with a random projection with the input ``random'' (including
  the quotes) in this entry field.
\item
  \texttt{height}: The initial height of the slice.
\item
  \texttt{heightRange}: The range of slice heights to be explored.
\item
  \texttt{legendQ}: A flag signaling whether the data matrix includes a
  column with group labels (1) or not (0).
\item
  \texttt{flagQ}: A flag signaling whether the data matrix includes a
  numerical flag for the groups.
\item
  \texttt{colorFunc}: specifies the colour mapping for the different
  groups.
\end{itemize}

The function renders a manual tour with controls that allow the user to
navigate through different projections. For a given projection, a slider
permits the user to change the slide width within its range and a
separate box switches the view to a projection. The user can also change
the centre point of slices; the size of the points rendered and the
scale of the plot through sliders. An additional box displays the
coordinates of the projection matrix explicitly.

This function can be used for ungrouped data setting legendQ and flagQ
to 0.

To remove a group from the visual display, the user can choose specific
colours for the entry colorFunc. For example, \{Red,White,Green\} would
display groups 1 (red) and 3 (green) while making 2 invisible.

Other functions are:

\begin{itemize}
\item
  \texttt{ProjectionPlot{[}data,\ projmat,\ legendNames(=\{\}),\ colorFunc(=ColorData{[}97{]}){]}}
  with arguments
\item
  \texttt{data}: A data matrix with one or more groups labeled by a flag
  (numerical)
\item
  \texttt{projmat}: The initial projection matrix. It is possible to
  start with a random projection with the input ``random'' (including
  the quotes) in this entry field.
\item
  \texttt{legendNames}: an optional list of labels for the groups.
\item
  \texttt{colorFunc}: specifies the colour mapping for the different
  groups.
\end{itemize}

This function is similar to SliceDynamic but can only display
projections. Using it instead of SliceDynamic simplifies the display and
is more efficient. The data file should not contain labels for groups,
if these are desired they are passed through the optional argument
legendNames as \{``group 1'', ``group 2'',\ldots\}, for example.

The display allows the user to navigate through different projections,
choose the point size and zoom the factor, and explicitly display the
coordinates of the projection.

\begin{itemize}
\item
  \texttt{ProjectedLocatorPlot{[}data,\ projmat,\ legendNames(=\{\}),\ colorFunc(=ColorData{[}97{]}){]}}
  with arguments
\item
  \texttt{data}: A data matrix with one or more groups labeled by a flag
  (numerical)
\item
  \texttt{projmat}: The initial projection matrix. It is possible to
  start with a random projection with the input ``random'' (including
  the quotes) in this entry field.
\item
  \texttt{legendNames}: an optional list of labels for the groups.
\item
  \texttt{colorFunc}: specifies the colour mapping for the different
  groups.
\end{itemize}

This function is very similar to ProjectionPlot but uses a different
display for navigation of projections in which each coordinate is
represented on a separate dial.

\begin{itemize}
\item
  \texttt{VisualiseSliceDynamic{[}data,\ projmat,\ height,\ heightRange{]}}
  with arguments
\item
  \texttt{data}: A data matrix containg only one set.In this case the
  data matrix should not contain column labels.
\item
  \texttt{projmat}: The initial projection matrix. It is possible to
  start with a random projection with the input ``random'' (including
  the quotes) in this entry field.
\item
  \texttt{height}: The initial height of the slice.
\item
  \texttt{heightRange}: The range of slice heights to be explored.
\end{itemize}

This function differs from SliceDynamic in that it looks at only one
data set but displays both the points inside and outside the slice. The
display panel allows the user to specify the size of both sets of points
(inside and outside) along with the slice height, centre point and zoom
level.

\bibliographystyle{tfcad}
\bibliography{biblio.bib}





\end{document}
