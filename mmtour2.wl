(* ::Package:: *)

BeginPackage["mmtour`"];


(* ::Section:: *)
(*Functions*)


(* ::Subsection:: *)
(*Dynamic Plots and Functions*)


(* ::Input::Initialization:: *)
ArrowText[p1_,txt_]:=
Text[txt, p1+{0.02,0.02}]


(* ::Input::Initialization:: *)
ArrowText::usage=
"A helper function which places text near the coordinate p1.
ArrowText[p1, txt]
p1: A coordinate which determines the position of the text.
txt: A string of text to be written.
";


(* ::Input::Initialization:: *)
MathFont[txt_]:=
Text[Style[txt, FontFamily->"Times New Roman"]]


(* ::Input::Initialization:: *)
MathFont::usage=
"A helper function which changes the font of the text to Times New Roman.
MathFont[txt]
txt: A string of text to change fonts.";


Clear[ProjectionPlot]
ProjectionPlot[data_,projmat_,legendNames_:{},colorFunc_:ColorData[97]]:=
(* Dynamic module allows retains instances of the local variables within the within the first list. 
 These local variables then can be changed by Dynamic expressions within DynamicModule and 
 all Dyanmic objects will be updated accordingly. For example, lst will be changed by user input,
 then it will be orthonormalised and finally Dynamic objects will be updated provided there is an instance of
 lst present within the Dynamic object.*)
DynamicModule[
(*Below are the local variables within the scope of DynamicModule, and they are being assigned inital values.
-> tempData is data but has the column names removed if there are any
-> lst is the projection matrix of the data, a random orthonormal matrix can be generated by the keyword "random"
 or the user can input a matrix
-> arrowData stores the column names (if there are none, then the columns are named x1, x2, ...),
 the position of the column names, the position of the heads of the arrows and the unit circle.
 This is used for the control module, and arrowData is updated when there are any changes made to
 the projection matrix "lst"
-> pntSize controls the point size of the projected data
-> legend stores the names for the legends
-> dataSets store a list of matrices that are sorted based on the colour index 
-> colours stores the colours that will be used for the plot based on the colour index
-> range preserves the plotting range for the projection/slice so that it doesn't change when the
  projection/slice changes. However, it is assumed the data is centred about the origin*)
{tempData = If[StringQ[data[[1, 1]]], data[[2;;-1]], data],
 lst=If[TrueQ[projmat=="random"], RandomMatrix[If[StringQ[data[[1, 1]]], data[[2;;-1]], data], 1],projmat], 
 arrowData, pntSize=0.01, legend=legendNames,
dataSets={}, colours={}, range=Max[Map[Norm, If[StringQ[data[[1, 1]]], data[[2;;-1, 1;;-2]], data[[All, 1;;-2]]]]]
},

(*This creates the neccesary data for arrowData. It can be seen that the command Arrow and Text are encased
within Dynamic as these objects need to be updated when there are any changes to the projection matrix
lst. It can also be seen that there is a command "With" within Do. This creates a local variable, n in this case,
within the scope of "with" and allows us to use every row of lst rather than lst[[i]]. 
(need to reaffirm that this is the case, but I remember arrowData having lst[[i]]
 for each row of the projection matrix rather than lst[[1]], lst[[2]] ...)*)
If[StringQ[data[[1, 1]]], 
arrowData=Reap[Sow[Circle[{0,0},1]];
Do[With[{n=i},
Sow[Dynamic[Arrow[{{0,0}, lst[[n]]}]]];
Sow[Dynamic[Text[StringForm[data[[1, n]]], lst[[n]]+lst[[n]]/20]]];],{i,1,Length[tempData[[1]]]-1}]][[2, 1]],

(*Note that Reap and Sow is just a different way of constructing a lst. It's slightly more efficent than
using Append/AppendTo*)
arrowData=Reap[Sow[Circle[{0,0},1]];
Do[With[{i=i},
Sow[Dynamic[Arrow[{{0,0},lst[[i]]}]]];
Sow[Dynamic[Text[StringForm["\!\(\*
StyleBox[\"x\",\nFontWeight->\"Plain\"]\)``",i], lst[[i]]+lst[[i]]/20]]];],{i,1,Length[tempData[[1]]]-1}]][[2, 1]]

];
(* Creating the list of matrices that are sorted by their colour index. It should be noted that
Mathematica assigns a colour to a data set rather than to each point within the data set.
So, it's more efficient to create data sets in mathematica *)
dataSets=CreateDataSets[tempData];

(*This creates names for the legends if neccesary*)
If[TrueQ[legend=={}],Do[With[{n=i},
AppendTo[legend,Style[StringForm["Index ``",i],FontFamily->"Times New Roman"]]],{i, 1, Length[dataSets]}]
];

(*Creates a matrix where each row is associated with a data set. So, each data set can be
assigned a unique colour, and each data set is utilising the same pointsize*)
Do[With[{n = i}, AppendTo[colours, {colorFunc[dataSets[[n, 1, -1]]], PointSize[Dynamic[pntSize]]}]];,
{i, 1, Length[dataSets]}];


(*Grid formats the ouput of dynamic module, this is what the user can interact with*)
Grid[{{
(*Slider allows the user to change the size of the points in the plot by updating
 the contents of pntSize*)
Slider[Dynamic[pntSize],{0,0.02}]},
{Text["Point Size:" Dynamic[pntSize 50]]},
{(*The line below preserves orthonormality of the projection matrix by extracting the the current values of
the columns that were just changed by the user, then applying the gram-schmidt algorithm on the columns and
then updating the columns of the local variable lst. The values of the recently orthonormalised matrix are then
used/displayed.

LocatorPane creates a set of interactive points based on lst, each row is an interactive point,
and Dynamic allows for lst to be updated and for a rule to be applied (Dynamic[lst, rule]). 
This rule uses the user input and transforms it appropriately, this is done by using a hashtag, brackets and 
an ampersand as seen below.
*)
LocatorPane[Dynamic[lst,({lst[[All, 1]], lst[[All,2]]}=Orthogonalize[{#[[All, 1]], #[[All, 2]]}])&],
(*This part of the code creates the main control module of the dynamic. The command Graphics displays 
graphics primitives that are stored within arrowData. Graphics doesn't need to be encased within Dynamic
as it is wthin LocatorPane, this command will update the display of the main control module appropriately*)
Graphics[arrowData, Frame->True,ImageSize->165],Appearance->None],
(*This creates the scatter plot of the projected data. Once again, listplot is within Dynamic as it needs
to be updated if there is a change in the projection matrix "lst" or colours *)
Dynamic[
ListPlot[
(*Map and Function allow for each data Set to be multiplied with the projection matrix*)
Map[Function[x,
(*(there is a bug I need to fix)*)
If[MissingQ[x],
{Missing[]}, 
(*The projection matrix is being applied to the data*)
x[[All, 1;;-2]]] . lst], 
dataSets],
(*Below are commands which change how the data is displayed/looks*)
PlotStyle->colours,
AxesOrigin->{0,0},
PlotRange->{{-range,range},{-range,range}},
AspectRatio->1,
(*Creates the legend for the data*)
PlotLegends->Placed[PointLegend[legend,LegendMarkerSize->15,LegendMarkers->{{"\[FilledCircle]",15}}],Above],
LabelStyle->FontFamily->"Times New Roman",
(*Ensures that performance is optmised when displaying the projection/slice.
Graphical glitches do happen if you are working with continuous surfaces*)
PerformanceGoal->"Speed",
AxesLabel->{"\!\(\*SubscriptBox[\(P\), \(1\)]\)", "\!\(\*SubscriptBox[\(P\), \(2\)]\)"},
ImageSize->650
]]},
(*Displays the current projection matrix associated with the data*)
{"Proj. Matrix:" Dynamic[Text[lst//MatrixForm]]}
},Background->Lighter[Gray,0.975],Frame->True]]


(* ::Input::Initialization:: *)
ProjectionPlot::usage=
"An dynamic plot of the projected data onto a 2D plane. The projection matrix can be 
determined and applied to the data by moving the projected axes/dimensions within
the unit circle. Orthonormality of the projection matrix is preserved within this dynamic.
ProjectionPlot[data, projmat, legendNames(={}), colorFunc(=ColorData[97])]
data: A data matrix where the last has positive integers which represent the group.
projmat: A projection matrix which describes the projection plane, the key word random can be used.
legendNames: A list of names for each group in ascending order.
colorFunc: A list of colours that are in ascending order or the inbuilt ColorData Function, ColorData[n] \[IndentingNewLine]";


(* ::Input::Initialization:: *)
(*Need to add legend names*)
Projected2DSliderPlot[data_,projmat_, colorFunc_:ColorData[97]]:=
(*This function is similar to ProjectionPlot except the main cotrol Module is different. Each row of the projection matrix has its own unit circle. This sort of implementation may be easier in another language*)
DynamicModule[
{tempData =If[StringQ[data[[1, 1]]], data[[2;;-1]], data], lst=If[TrueQ[projmat=="random"],RandomMatrix[If[StringQ[data[[1, 1]]], data[[2;;-1]], data], 1],projmat], locatorLst={}, txtLst={},dataSets={}, colours={},pntSize=0.005,legend={},range=Max[Map[Norm,If[StringQ[data[[1, 1]]], data[[2;;-1, 2;;-1]], data[[All, 2;;-1]]]]]},


If[StringQ[data[[1, 1]]], txtLst=data[[1, 1;;-2]], Do[With[{n = i}, AppendTo[txtLst,Style[ StringForm["x ``", n], FontFamily->"Times New Roman"]]
],{i, 1, Length[data[[1]]]-1}]];

(*This portion creates the locator panes for the Dyanmic. It can be seen that a local variable "n" is being 
used as each instance of each row needs to be used. If a local variable isn't used then lst[[i]] will be
used. Each row of the projection matrix has there own locator pane, and the projection matrix is being orthonormalised by " Orthogonalize[{ReplacePart[lst, n->#][[All, 1]],ReplacePart[lst, n->#][[All, 2]]}]".
This command allows for row "n" to be replaced by the user input, and then the matrix is orthonormalised.
lst is then updated.*)
Do[With[{n = i},AppendTo[locatorLst,LocatorPane[Dynamic[lst[[n]],({lst[[All, 1]], lst[[All, 2]]}
=Orthogonalize[{ReplacePart[lst, n->#][[All, 1]],ReplacePart[lst, n->#][[All, 2]] }])& ],Graphics[{Circle[{0,0},1],Dynamic[Arrow[{{0,0},lst[[n]]}]]},ImageSize->120,Axes->True],Appearance->None]]],{i, 1, Length[data[[1]]] - 1}];
locatorLst=AppendTo[locatorLst,SpanFromAbove];



dataSets=CreateDataSets[tempData];

Do[colours = Append[colours, {colorFunc[dataSets[[i, 1, -1]]], PointSize[Dynamic[pntSize]]}];,
{i, 1, Length[dataSets]}];

Do[With[{n=i},legend=AppendTo[legend,Style[StringForm["Index ``",i],FontFamily->"Times New Roman"]]],{i, 1, Length[dataSets]}];

Grid[{
txtLst,
locatorLst,
{Text["Size of Points"],SpanFromLeft},
{Slider[Dynamic[pntSize], {0,0.01}], SpanFromLeft},
{Dynamic[ListPlot[Map[Function[x,
If[
MissingQ[x],
(*Bug I need to fix*)
{Missing[]}, 
x[[All, 1;;-2]]] . lst], 
dataSets],
PlotStyle->colours,
PlotRange->{{-range, range}, {-range,range}},
AspectRatio->1,
PlotLegends->Placed[PointLegend[legend,LegendMarkerSize->15,LegendMarkers->{{"\[FilledCircle]",15}}],Left],
AxesLabel->{"\!\(\*SubscriptBox[\(P\), \(1\)]\)", "\!\(\*SubscriptBox[\(P\), \(2\)]\)"},
LabelStyle->FontFamily->"Times New Roman",
ImageSize->680]], SpanFromLeft},
{"Proj. Matrix:" Dynamic[Text[lst//MatrixForm]]}},Background->Lighter[Gray,0.975],Frame->True]
]


(* ::Input::Initialization:: *)
Projected2DSliderPlot::usage=
"An dynamic plot of the projected data onto a 2D plane. The projection matrix can be 
determined and applied to the data by moving 2D sliders. Each slider corresponds to a 
projected dimension. The centre of the sliders is (0, 0), and orthonormality of the
projection matrix is preserved within this dynamic.
Projected2DSliderPlot[data, projmat, colorFunc(=ColorData[97])]
data: A data matrix where the last contains positive integers that represent the group.
projmat: A projection matrix which describes the projection plane, the key word random can also be used.
colorFunc: A list of colours that are in ascending order or the inbuilt ColorData Function, ColorData[n]
";


(* ::Input::Initialization:: *)
VisualiseSliceDynamic[data_,projmat_,height_,heightRange_,minDist_:0]:=
(*This function allows you to visualise the slice by displaying what points are in the slice with one colour,
and what points are outside the slice in another colour.*)
(*Dynamic Module is similar to Dynamic Module in projectionPlot*)
DynamicModule[{
lst=If[TrueQ[projmat=="random"],RandomMatrix[data, 0],projmat],centre =ConstantArray[0, Length[data[[1]]]] ,h=height,arrowData, pntSize1=0.005, pntSize2=0.004,range=Max[Map[Norm,If[StringQ[data[[1, 1]]], data[[2;;-1, 2;;-1]], data[[All, 2;;-1]]]]]},
arrowData=Reap[Sow[Circle[{0,0},1]];Do[With[{i=i},
Sow[Dynamic[Arrow[{{0,0},lst[[i]]}]]];
Sow[Dynamic[Text[StringForm["\!\(\*
StyleBox[\"x\",\nFontWeight->\"Plain\"]\)``",i], lst[[i]]+lst[[i]]/20]]];],{i,1,Length[data[[1]]]}]][[2, 1]];

(*Grid formats the ouput of dynamic module*)
Grid[{{"Centre Point"},
(*Allows the user to input a centre point of a slice, and then updates the slice and centre point by
pressing enter*)
{InputField[Dynamic[centre],FieldSize->15]},
{"Slice Height"},
(*Allows the user to change the height of the slice with a slider*)
{Slider[Dynamic[h],heightRange]},
{Dynamic[h]},(*The line above preserves orthonormality*)
{"Size of Points in Slice"},
(*Allows the sure to change the point size of the points that are in the slice/outside the slice*)
{Slider[Dynamic[pntSize1],{0, 0.01}]},
{"Size of Points Outside of Slice"},
{Slider[Dynamic[pntSize2],{0, 0.01}]},
(*The usage of LocatorPane is the same in ProjectionPlot*)
{LocatorPane[Dynamic[lst,({lst[[All, 1]], lst[[All,2]]}=Orthogonalize[{#[[All, 1]], #[[All, 2]]}])&],
Graphics[arrowData,Frame->True,ImageSize->165],Appearance->None],

(*(If this part of the code isn't using module, then a recursion error occurs for some reason.
I need to determine why)*)
(*This creates the slice to be plotted. Module creates local variables *)
Dynamic[Module[{tempData=data, v1={},v2},

(*The line below determines which points exist within the slice and
appends them to a lst called v1. The slice is being determined by
formulae provided in "Hollowness in high dimensional data" *)

(*The local variable tempData is being modified if the point happens to be in the slice.
If a point is in the slice, then it is removed from tempData*)
Do[If[minDist<genDist[xPrime[data[[i]], lst], cPrime[centre, lst]]<h, 
AppendTo[v1, data[[i]]];tempData[[i]]=Nothing],{i,1,Length[data]}];
(*tempData is now assigned to the local variable v2*)
v2=tempData;

(*This creates the plot showing the slice. ListPlot is already encased in Dyanmic*)
ListPlot[{If[Length[v1]==0,{Missing[]},v1 . lst],If[Length[v2]==0,{Missing[]},v2 . lst]},
AspectRatio->1,
PlotStyle->{{Black,Opacity->1,PointSize[pntSize1]},{Lighter[Blue],Opacity->0.5,PointSize[pntSize2]}},
PlotRange->{{-range, range},{-range,range}},
AxesLabel->{"\!\(\*
StyleBox[\"P1\",\nFontSlant->\"Italic\"]\)", "\!\(\*
StyleBox[\"P2\",\nFontSlant->\"Italic\"]\)"},
LabelStyle->FontFamily->"Times New Roman",
AspectRatio->1,
ImageSize->500,
PlotLegends->Placed[{"In Slice","Not in Slice"},Above]]
]
],SpanFromAbove},
{"Proj. Matrix:" Dynamic[Text[lst//MatrixForm]]}},Frame->True]]


(* ::Input::Initialization:: *)
CreateDataSets[data_]:=
(*This function creates Data sets based on the last column of data*)
Module[{sortedData ={},lst={}, dataSets={}, val},
(*Sorting based on the last collumn of data (Mathematica attempts to use the most efficent sorting algorithm)*)
sortedData = Sort[data, #1[[-1]]<#2[[-1]]&];
val=sortedData[[1,-1]];
val;
(*creating the data sets*)
For[i = 1,i<=Length[data],i++,
If[val ==sortedData[[i, -1]],
lst = Append[lst, sortedData[[i]]],
val=sortedData[[i, -1]];
dataSets=Append[dataSets, lst];
lst = {sortedData[[i]]};
]
];
dataSets=Append[dataSets, lst];
Return[dataSets]
]


RandomMatrix[data_,col_] :=
(*This function creates a random matrix based on the dimension of data.
If the last column of data represents groups, then a 1 is used for col. Otherwise, 0 is used.*)
    Module[{len = Length[data[[1]]] - col, mat = {}},
        Do[mat = AppendTo[mat, {RandomReal[{-1, 1}],RandomReal[{-1, 1}]}], len];
        mat = Transpose[Orthogonalize[Transpose[mat]]];
        Return[mat]
    ]
    (*Probably can compile this function*)


(* ::Input::Initialization:: *)
Clear[SliceDynamic]
SliceDynamic[data_,projmat_,height_,heightRange_, legendNames_:{}, colorFunc_:ColorData[97]]:=
DynamicModule[{
tempData =If[StringQ[data[[1, 1]]], data[[2;;-1]], data], lst=If[TrueQ[projmat=="random"],RandomMatrix[If[StringQ[data[[1, 1]]], data[[2;;-1]], data], 1],projmat],
centre =ConstantArray[0,Length[data[[1]]]- 1] ,h=height,dataSets,arrowData,pntSize=0.006, range=Max[Map[Norm, If[StringQ[data[[1, 1]]], data[[2;;-1, 1;;-2]], data[[All, 1;;-2]]]]], legend=legendNames, colours={}, boolVal = False
},

If[StringQ[data[[1, 1]]], 
arrowData=Reap[Sow[Circle[{0,0},1]];
Do[With[{i=i},
Sow[Dynamic[Arrow[{{0,0},lst[[i]]}]]];
Sow[Dynamic[Text[StringForm[data[[1, i]]], lst[[i]]+lst[[i]]/20]]];],{i,1,Length[tempData[[1]]]-1}]][[2, 1]],

arrowData=Reap[Sow[Circle[{0,0},1]];
Do[With[{i=i},
Sow[Dynamic[Arrow[{{0,0},lst[[i]]}]]];
Sow[Dynamic[Text[StringForm["\!\(\*StyleBox[\"x\",\nFontWeight->\"Plain\"]\)``",i],
lst[[i]]+lst[[i]]/20]]];],
{i,1,Length[tempData[[1]]]-1}]][[2, 1]]

];

dataSets=CreateDataSets[tempData];

If[TrueQ[legend=={}],Do[With[{n=i},
AppendTo[legend,Style[StringForm["Index ``",i],FontFamily->"Times New Roman"]]],{i, 1, Length[dataSets]}]
];

Do[With[{n=i}, AppendTo[colours, 
{If[ListQ[colorFunc],
colorFunc[[dataSets[[i, 1, -1]]]], 
colorFunc[dataSets[[i, 1, -1]]]],
PointSize[Dynamic[pntSize]]}]],
{i, 1, Length[dataSets]}];



Grid[{{"Centre Point"},
{InputField[Dynamic[centre],FieldSize->15]},

{"Slice Height:"Dynamic[h]},
{Slider[Dynamic[h],heightRange]},
{"Point Size:" Dynamic[100 pntSize]},
{Slider[Dynamic[pntSize],{0,0.02}]},
{"Projection:" Dynamic[boolVal]},
(*This determines whether a projection or a slice will be displayed in the output*)
{Checkbox[Dynamic[boolVal]]},
{LocatorPane[Dynamic[lst,({lst[[All, 1]], lst[[All,2]]}=Orthogonalize[{#[[All, 1]], #[[All, 2]]}])&],
Graphics[arrowData,Frame->True,ImageSize->165],Appearance->None],

Dynamic[Module[{sliceSet ={}, slice={}},

Do[Do[If[genDist[xPrime[dataSets[[i,j, 1;;- 2]], lst], cPrime[centre, lst]]<h,
slice = Append[slice, dataSets[[i,j,1;;-2]]];
],{j, 1, Length[dataSets[[i]]]}];

(*I'm ensuring that I won't have a list of empty lists. Multiply a single empty list, {}, with projmat is fine.*)
If[Length[slice]>0, 
AppendTo[sliceSet, slice],
AppendTo[sliceSet, Missing[]]
];

slice ={},
{i, 1, Length[dataSets]}];


ListPlot[
(*The if statement which determines whether a slice or a projection will be displayed*)
If[boolVal,Map[Function[x,
If[
(*The commmand Missing[] allows for empty sets to be plotted, 
but still have a legend that represents that currently empty set.
This especially important to slicing*)
MissingQ[x],
{Missing[]}, 
x[[All, 1;;-2]]] . lst], 
dataSets],
 Map[Function[x,
If[
MissingQ[x], 
{Missing[]}, 
x . lst]], sliceSet]
],
AxesLabel->{"\!\(\*
StyleBox[\"P1\",\nFontSlant->\"Italic\"]\)", "\!\(\*
StyleBox[\"P2\",\nFontSlant->\"Italic\"]\)"},
PlotStyle->colours,
LabelStyle->FontFamily->"Times New Roman",
PlotLegends->Placed[PointLegend[legend,LegendMarkerSize->15,LegendMarkers->{{"\[FilledCircle]",15}}],Above],
 AspectRatio->1,PlotRange->{{-range, range},{-range, range}},
ImageSize->500
]
]]
,SpanFromAbove},
{"Proj. Matrix:" Dynamic[Text[lst//MatrixForm]]}},Frame->True]]


(* ::Input::Initialization:: *)
VisualiseSliceDynamic::usage=
"A function where you can plot a slice and manually change the specifications of the slice such as the projection matrix, slice height and the slice positions.
SliceDynamic[data, projmat, height, heightRange, legendNames, colorFunc]
data: A data matrix
projmat: The inital projection matrix
height: The initial height of the slice
heightRange: The range of heights
legendNames: A list of names for each group in ascending order.
colorFunc: A list of colours that are in ascending order or the inbuilt ColorData Function, ColorData[n] 
";


(* ::Subsection:: *)
(*Slicing Functions*)


(* ::Input::Initialization:: *)
(*These functions are helper functions which determine the slice for given specifcations. The functions are complied to help improve efficiency*)
cPrime=Compile[{{c,_Real,1},{projMat,_Real,2}},
c-(c . projMat[[All, 1]])projMat[[All, 1]]-(c . projMat[[All, 2]])projMat[[All, 2]], CompilationTarget->"C"];


(* ::Input::Initialization:: *)
cPrime::usage=
"A hepler function which determines the orthogonal component of the vector v with respect to the projection
plane described by projMat. v also dictates where the projection plane will be positioned.
cPrime[c, projMat]
c: A vector which describes the position of the projection plane (i.e. where you want to slice the data)
projMat: A projection matrix which describes the projection plane/slice
";


(* ::Input::Initialization:: *)
xPrime=Compile[{{xRow,_Real, 1},{projMat,_Real, 2}},
xRow-(xRow . projMat[[All, 1]])projMat[[All, 1]]-(xRow . projMat[[All, 2]])projMat[[All, 2]], CompilationTarget->"C"];


(* ::Input::Initialization:: *)
xPrime::usage=
"A helper function which determines the normal from the projection plane to the point xRow.
xPrime[xRow, projMat]
xRow: A point/an observation from the data matrix
projMat: A projection matrix which describes the projection plane	
";


(* ::Input::Initialization:: *)
genDist=Compile[{{xP,_Real,1},{cP,_Real,1}},
Sqrt[xP . xP+cP . cP-2xP . cP], CompilationTarget->"C"];


(* ::Input::Initialization:: *)
genDist::usage=
"A function which determines the generalised orthogonal distance between a point in space and
the projection plane. 
genDist[xP, cP]
xP: Ideally the xPrime function
cP: Ideally the cPrime function
";


EndPackage[];
