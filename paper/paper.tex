% interactcadsample.tex
% v1.03 - April 2017

\documentclass[]{interact}

\usepackage{epstopdf}% To incorporate .eps illustrations using PDFLaTeX, etc.
\usepackage{subfigure}% Support for small, `sub' figures and tables
%\usepackage[nolists,tablesfirst]{endfloat}% To `separate' figures and tables from text if required

\usepackage{natbib}% Citation support using natbib.sty
\bibpunct[, ]{(}{)}{;}{a}{}{,}% Citation support using natbib.sty
\renewcommand\bibfont{\fontsize{10}{12}\selectfont}% Bibliography support using natbib.sty

\theoremstyle{plain}% Theorem-like structures provided by amsthm.sty
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}

\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{notation}{Notation}


% tightlist command for lists without linebreak
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\def\tightlist{}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{nicematrix}
\NiceMatrixOptions{code-for-first-row = \color{red} ,code-for-last-row = \color{red} ,code-for-first-col = \color{blue} ,code-for-last-col = \color{blue}}


\begin{document}


\articletype{Short Technical Note}

\title{A new simplified manual tour, with application to exploring
classification boundaries in high dimensions}


\author{\name{Alex Aumann$^{a}$, German Valencia$^{a}$, Ursula
Laa$^{b}$, Dianne Cook$^{c}$}
\affil{$^{a}$School of Physics and Astronomy, Monash
University; $^{b}$Institute of Statistics, University of Natural
Resources and Life Sciences, Vienna; $^{b}$Department of Econometrics
and Business Statistics, Monash University}
}

\thanks{CONTACT Alex
Aumann. Email: \href{mailto:aaum0002@student.monash.edu}{\nolinkurl{aaum0002@student.monash.edu}}, German
Valencia. Email: \href{mailto:german.valencia@monash.edu}{\nolinkurl{german.valencia@monash.edu}}, Ursula
Laa. Email: \href{mailto:ursula.laa@boku.ac.at}{\nolinkurl{ursula.laa@boku.ac.at}}, Dianne
Cook. Email: \href{mailto:dicook@monash.edu}{\nolinkurl{dicook@monash.edu}}}

\maketitle

\begin{abstract}
Something here
\end{abstract}

\begin{keywords}
data visualisation; grand tour; statistical computing; statistical
graphics; multivariate data; dynamic graphics
\end{keywords}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

From a statistical perspective it is rare to have data that are strictly
3D, and so unlike in most computer graphics applications, the more
useful methods for data analysis show projections from an arbitrary
dimensional space. These are dynamic data visualizations methods and are
collected under the term \emph{tours}. Tours involve views of
high-dimensional (\(p\)) data in low-dimensional (\(d\)) projections. In
his original paper on the grand tour, \citet{As85} provided several
algorithms for tour paths that could theoretically show the viewer the
data \emph{from all sides}. Prior to Asimov's work, there were numerous
preparatory developments including \citet{tukey}'s PRIM-9. PRIM-9 had
user-controlled rotations on coordinate axes, allowing one to manually
tour through low-dimensional projections. It is impractical to
impossible to steer through all possible projections, unlike Asimov's
tours which allows one to quickly see many, many different projections.
After Asimov there have been many, many tour developments, as summarized
in \citet{lee2021}.

One such direction of work develops the ideas from PRIM-9, to provide
manual control of a tour. \citet{cook_manual_1997} describes controls
for 1D (or 2D) projections, in a 2D (or 3D) manipulation space, allowing
the user to select any variable axis, and rotate it into or out of or
around the projection through horizontal, vertical, oblique, radial or
angular changes in value. \citet{spyrison_spinifex_2020} refines this
algorithm and implements them to generate animations.

Manual controls are especially useful for assessing sensitivity of
structure to particular elements of the projection. There are many
places where it is useful. In exploratory data analysis, where one sees
clusters in a projection, can some variables be removed from the
projection without affecting the clustering. For interpreting models,
one can reduce or increase a variable's contribution to examine the
variable importance. These controls can also be used to interactively
generate faceted plots \citep{XXX}, or spatiotemporal glyphmaps
\citep{XXX}. Having the user interact with a projection is extremely
valuable for understanding high-dimensional data. However, these
algorithms have two problems: (1) the pre-processing of creating a
manipulation space overly complicates the algorithm, (2) extending to
higher dimensional control is difficult.

Through experiments with the relatively new interactive graphics
capabilities in mathematica(?), we have realized that there is a simpler
approach, which is more direct, and extensible for generating user
interaction. This paper explains this, and is organized as follows. The
next section describes the new algorithm for manual control. This is
followed by details on implementation. The applications section
illustrate how these can be used.

\hypertarget{sec:method}{%
\section{What is a manual tour}\label{sec:method}}

An orthonormal basis (\(A_{p\times d}\)) and a variable id
(\(m \in \{1, ..., p\}\)) to control are provided to initialize a manual
tour. A method to update the values of the component of the controlled
variable \(V_m\) is needed.

\hypertarget{existing-methods}{%
\subsection{Existing methods}\label{existing-methods}}

In the original work, the method for updating component values, for a 2D
projection, was built trackball controls in 3D. A 3D manipulation space
is created, as illustrated in Figure \ref{manipspace}, where the
controlled variable has full range of motion from -1 to 1. Movements of
a cursor are recorded and converted into changes in the values of
\(V_m\) to change it's values in the displayed 2D projection. Movement
could also be constrained to be only in horizontal, vertical, radial or
angular motions.

\begin{figure*}[ht]
\centerline{\includegraphics[width=0.8\textwidth]{figures/manip_space.pdf}}
\caption{Original contruction of the manual tour designed for 2D projections and created a 3D space from which to utilise track ball controls to change it's contribution. (Figure 3 from Cook and Buja (1997).)}
\label{manipspace}
\end{figure*}

\hypertarget{the-new-simpler-definition}{%
\subsection{The new simpler
definition}\label{the-new-simpler-definition}}

The new approach emerged from experiments in mathematica. The components
corresponding to \(V_m\) are directly controlled by cursor movement,
which updates row \(m\) of \(A\). The updated matrix is then
orthonormalised.

\hypertarget{algorithm-1}{%
\subsubsection{Algorithm 1}\label{algorithm-1}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Provide \(A\), and \(m\). (Note that \(m\) could also be automatically
  chosen as the component that is closest to the cursor position.)
\item
  Change values in row \(m\), giving \(A^*\). A large change in these
  values would correspond to making a large jump from the current
  projection. Small changes would correspond to tracking a cursor,
  making small jumps from the current projection.
\item
  Orthonormalise \(A^*\), using Gram-Schmidt. For \(d=2\), and
  \(A^* = \left[ {\boldmath a}_{.1}~{\boldmath a}_{.2}\right]\), the
  steps are:

  \begin{enumerate}
  \def\labelenumii{\roman{enumii}.}
  \tightlist
  \item
    Normalise \({\boldmath a}_{.1}\), and \({\boldmath a}_{.2}\).
  \item
    \({\boldmath a}^*_{.2} = {\boldmath a}_{.2} - {\boldmath a}_{.1}^T{\boldmath a}_{.2}{\boldmath a}_{.1}\).
  \item
    Normalise \({\boldmath a}^*_{.2}\).
  \end{enumerate}
\end{enumerate}

This algorithm will produce the changes to a projection as illustrated
in Figure \ref{fig:manualsequence} (top row). The controlled variable,
\(V_m\), corresponds to the black line, and sequential changes to row
\(m\) of \(A\) can be seen to roughly follow a specified position
(orange dot). Changes in the other components happen as a result of the
orthonormalisation, but are uncontrolled.

\hypertarget{algorithm-2}{%
\subsubsection{Algorithm 2}\label{algorithm-2}}

The problem with Algorithm 1 is that the precise values for \(V_m\)
cannot be specified because the orthonormalisation will change them.
This modification will maintain the components of \(V_m\) precisely
(Figure \ref{fig:manualsequence} (bottom row)). The algorithm is as
follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Provide \(A\), and \(m\).
\item
  Change values in row \(m\), giving \(A^*\).
\item
  Store row \(m\) separately, and zero the values of row \(m\) in
  \(A^*\), giving \(A^{*0}\).
\item
  Orthonormalise \(A^{*0}\), using Gram-Schmidt.
\item
  Replace row \(m\) with the original values, giving \(A^{**}\).
\item
  For \(d=2\), adjust the values of \({\boldmath a}^{**}_{.2}\) using
\end{enumerate}

\[a^{**}_{j2}+\frac{a_{m1}a_{m2}}{p-1}, j=1, ..., p, j\neq m\].

which ensures that

\[\sum_{j=1, j\neq m}^p a^{**}_{j1}a^{**}_{j2} + a_{m1}a_{m2} = 0\].

If \(d>2\) the process would be sequentially repeated in the same manner
that Gram-Schmidt is applied sequentially to orthormalise the columns of
a matrix. If \(d=1\) no orthonormalisation is needed, and the projection
vector would simply need to be normalized after each adjustment.

\hypertarget{algorithm-3}{%
\subsubsection{Algorithm 3}\label{algorithm-3}}

For \(d=2\) projections, the projection matrix is the sub-matrix of
\(A\) formed by its first two columns. Whereas orthonormality of the
basis for the p-dimensional space is given by
\(e_i\cdot e_j=\delta_{ij},{i,j,=1,\cdots,}\), orthonormality of the
projection matrix is expressed as
\(P_i\cdot P_j=\delta_{ij}, {i,j=1,2}\). Movement of the cursor takes
the two components \({x_{m1},x_{m2}}\) into a selected new value
\({a,b}\). Although the motion is constrained by \(a^2+b^2\leq 1\), this
is not sufficient to guarantee orthonormality of the new projection
matrix. One possible algorithm to achieve this is

\begin{enumerate}
\item Cursor movement takes ${x_{m1},x_{m2}}\to {a,b}$
\item The freedom to change the components $A_{i3}\cdots A_{ip}$ (the columns of $A$ not corresponding to the projection matrix) is used to select a new orthonormal basis as follows:
\begin{enumerate}
\item For row $m$ one chooses $A_{m3}=\sqrt{1-a^2-b^2},~A_{m,k>3}=0$
\item For other rows, $A_{i\neq m,j\geq3}$ random selections in the range $(-1,1)$ are made.
\item The Gram-Schmidt algorithm is then used to obtain an orthonormal basis taking $e_m$ as the first vector (which is already normalized), and then proceeding as usual $e_1\to e_1-(e_1\cdot e_m) e_m$, $e_1\to e_1/(e_1\cdot e_1)$, etc.
\end{enumerate}
\item this results in the orthonormal basis $A^*$ and a new projection matrix with $P_{m1}=a,~P_{m2}=b$.
\end{enumerate}

The random choice for the components of \(A\) not in the projection
matrix allows the exploration of dimensions perpendicular to the
projection plane.

\begin{align}
A=~~~& \begin{pNiceArray}{ccccc}[first-row,first-col]
\CodeBefore
       \columncolor{red!15}{1,2}
              \rowcolor{blue!15}{4}
     \Body
       & \stackrel{P_1}{\downarrow} & \stackrel{P_2}{\downarrow} &  & &\\
e_1\to & x_{11} & x_{12}  & x_{13} & \cdots & x_{1p} \\
e_2 \to& x_{21}  & x_{22}  & \cdot  &\cdots & x_{2p} \\
\vdots ~~~&\vdots & \vdots  & \vdots & \ddots & \vdots \\ 
 e_m \to& x_{m1}  & x_{m2}  & \cdot  &\cdots & x_{mp} \\   
\vdots ~~~&\vdots & \vdots  & \vdots & \ddots & \vdots \\
e_p \to&x_{p1} & x_{p2} &\cdot &\cdots & x_{pp} 
\end{pNiceArray},\quad (x_{m1},x_{m2})\to (a,b)
\end{align}

\begin{figure}
\includegraphics[width=1\linewidth]{paper_files/figure-latex/manualsequence-1} \caption{Sequence of projections where contribution of one variable is controlled (black) is changed: (top) unconstrained orthonormalisation, (bottom) constrained as specified. The dot (orange) indicates the chosen values for the controlled variable. For the constrained orthonormalisation it can be seen to precisely match the axis, but not so for the unconstrained orthonormalisation.}\label{fig:manualsequence}
\end{figure}

\hypertarget{potential-algorithm-3}{%
\subsubsection{Potential Algorithm 3}\label{potential-algorithm-3}}

For now just sketching the idea:

\begin{itemize}
\tightlist
\item
  first step is to click on the axis display to change the contribution
  of one variable \(m\)
\item
  capture that position and replace the corresponding row in the
  projection matrix
\item
  for 2D projection this gives components \(m_1\) along ``x'' direction
  and \(m_2\) along \(y\) direction
\item
  next step: rotate basis such that direction of row m now corresponds
  to the first basis vector, this means we apply 2x2 rotation matrix to
  each row of the projection matrix, where the rotation angle is
  \(tan(\theta) = m_2/m_1\) (that matrix can be written just in terms of
  that ratio, \(x= m_2/m_1\), when \(m_1<0\) I think we just need to
  translate \(\theta \rightarrow \theta + \pi\))
\item
  take the rotated basis, apply Gram-Schmidt, now the direction of \(m\)
  will not change (but the length will change during normalization)
\item
  rotated back to the original xy basis to update the plots
\end{itemize}

XXX need to check calculation of angle when \(m_1 < 0\)

\begin{figure}
\includegraphics[width=1\linewidth]{paper_files/figure-latex/othermethod-1} \caption{Manual controls with algorithm 2. The precise location of the axis is maintained.}\label{fig:othermethod}
\end{figure}

\hypertarget{sec:implementation}{%
\section{Experimenting with new techniques using
Mathematica}\label{sec:implementation}}

\begin{itemize}
\tightlist
\item
  \textbf{Why is this a good sandbox}
\item
  \textbf{Explain the functionality available in the notebooks}
\end{itemize}

The following functions are implemented in the Mathematica package
\texttt{mmtour.wl}:

\begin{itemize}
\item
  \texttt{ProjectionPlot{[}data,\ projmat,\ xRange(=Automatic),\ yRange(=Automatic),\ \ colour(=Automatic){]}}
  with arguments

  \begin{itemize}
  \tightlist
  \item
    \texttt{data}: A list of data matrices (they must all have the same
    dimensionality)
  \item
    `\texttt{projmat}: A projection matrix which describes the
    projection plane. This is the initial projection and does not need
    to be orthonormal (XXX is this right?).
  \item
    `\texttt{xRange}: A list which details the range of the horizontal
    axis.
  \item
    `\texttt{yRange}: A list which details the range of the vertical
    axis.
  \item
    `\texttt{colour}: A list of graphics directives to be applied to
    each data matrix.
  \end{itemize}
\end{itemize}

There are problems with the default values for x and y ranges and
colour. It would be better to fix the ranges and colour based on the
data as well as the origin of axes and the size of the points.

\textbf{It would be good if the initial projection matrix (and maybe the
center) had default values. Perhaps a random matrix with the correct
dimensions read from the data? Fix 1}

The format for the printed projection matrix can be improved also. Maybe
fix the number of digits and the position of the label.

\begin{itemize}
\item
  \texttt{SlicePlot{[}data,\ projmat,\ centrePoint,\ height,\ heightRange,\ ptSize1(=0.005),\ ptSize2(=0.004),\ minDist(=0){]}}
  with arguments (used to be called SliceDynamic in Alex's first
  version, the name SliceDynamic was taken by something else below)

  \begin{itemize}
  \tightlist
  \item
    \texttt{data}: A data matrix
  \item
    \texttt{projmat}: The inital projection matrix
  \item
    \texttt{centrepoint}: The initial position of the slice
  \item
    \texttt{height}: The initial height of the slice
  \item
    \texttt{heightRange}: The range of heights
  \item
    \texttt{ptSize1}: The size of the points that exist within the slice
  \item
    \texttt{ptSize2}: The size of the points that exist outside of the
    slice
  \end{itemize}
\end{itemize}

This function requires some auxiliary functions. It does not accept more
than one data set.

\textbf{It would be good if the initial projection matrix (and maybe the
center) had default values. Perhaps a random matrix with the correct
dimensions read from the data?}

It may be good to fix the size of the points, the center of the axes and
the scales of the axes rather than allow them to change as the
projection and slicing changes

\begin{itemize}
\item
  \texttt{SliceDynamic{[}data,\ projmat,\ centrePoint,\ height,\ heightRange,\ ptSize1\ :\ 0.005,\ ptSize2\ :\ 0.004{]}}
  with arguments
\item
  \texttt{data}: A data matrix with an extra grouping or clustering
  column (numerical)
\item
  \texttt{projmat}: The initial projection matrix
\item
  \texttt{centrepoint}: The initial position of the slice
\item
  \texttt{height}: The initial height of the slice
\item
  \texttt{heightRange}: The range of heights
\item
  \texttt{ptSize1}: The size of the points that exist within the slice
\item
  \texttt{ptSize2}: The size of the points that exist outside of the
  slice
\end{itemize}

\textbf{Does this need to be a separate function from SlicePlot? Fix 2}

\textbf{It would be good if the initial projection matrix (and maybe the
center) had default values. Perhaps a random matrix with the correct
dimensions read from the data? Fix 3}

\textbf{It may be good to fix the size of the points, the center of the
axes and the scales of the axes rather than allow them to change as the
projection and slicing changes. Fix 4}

\textbf{I have found it useful to input different data sets rather than
have this function sort them automatically using the last column. One
data set with a flag column at the end, is best! Is the code too
complicated? Fix 5}

\begin{itemize}
\tightlist
\item
  \texttt{Projected2DSliderPlot{[}{]}}
\end{itemize}

This function uses a different display for the projection that I find
very useful. However as it stands it is specific to one data set. Needs
to be generalised to arbitrary data if we want to keep it.

\textbf{For Alex to do}

\begin{itemize}
\tightlist
\item
  \textbf{We would need a screenshot (and video) for each of these.}
\item
  \textbf{Fix 1, 2, 3, 4, 5}
\item
  \textbf{Code consistent for applications to work - see
  slice\_tour\_compare\_sets.nb. See below}

  \begin{itemize}
  \tightlist
  \item
    \textbf{We need to make sure the drawing range is fixed (no resizing
    of the axis when changing projection or slicing). It could be nice
    if there was a manual zoom in/zoom out to change scale
    occasionally.}
  \item
    \textbf{Should also make sure the size of the points is fixed (maybe
    this will be automatic if the drawing range is fixed?), bigger
    points would be preferred, currently the size is sometimes really
    tiny and it becomes difficult to see anything.}
  \item
    \textbf{Can we have some heuristic to decide the range for the slice
    thickness slider? In the second graph there is a tiny part of the
    slider where the changes are interesting, difficult to navigate
    since this makes it super sensitive to any small movement, while
    most of the options are not interesting. My suggestion would be to
    keep (as I understand is the case now) the maximum thickness (all
    points in) as the upper bound, but instead of zero use a thickness
    below which slices tend to be empty as the lower bound.}
  \item
    \textbf{For the olives example I think the relation between x2 and
    the blue region could be interesting.}
  \item
    \textbf{pdfsense data: can we use random samples instead of the
    first 10k rows? Then we should still be able to see the bigger
    picture (with picking the first ones we get some artificial
    structure from how the data was sampled initially).}
  \item
    \textbf{I was playing around with this today. Looks like the axes
    are fixed when changing slice thickness, but not when rotating?}
  \item
    \textbf{Anyways, some observations that might be useful, but all of
    this seems difficult for including in a paper:}
  \item
    \textbf{In the first example we can show how the yellow group is
    associated with the first variable (x1, I guess this is C9?) - when
    slicing through the center it only appears when x1 has a bigger
    component on the projection, it is associated with low values of x1.
    Since they are not near the average value of x1 the points do not
    get captured in a slice where x1 is not important in the projection.
    We can move the center point to -1 in the first component to then
    explore how the yellow group relates to the other three variables.
    Much less clear, maybe some indication of smaller x2 and larger x3
    for this.}
  \item
    \textbf{The second example is too busy for manual exploration I
    would say (too many axes to move around separately).}
  \item
    \textbf{Third example could be similar to the first: blue region
    requires small values of x2, can be understood from the exploration,
    then move center point to -0.5 in x2 to explore further. Now
    interpretation becomes tricky. Sometimes blue and yellow seem just
    randomly everywhere, sometimes blue more contained in an ellipsoid
    around the center (indicating some correlation between variables).
    For example try zeroing out components 2 and 3 to see this slice in
    x1 vs x4.}
  \item
    \textbf{For the last example x4 seems to be the one to work with. I
    feel like this is again very similar, maybe better to instead
    explore other examples (maybe something without slicing?)}
  \end{itemize}
\end{itemize}

\hypertarget{sec:examples}{%
\section{Applications}\label{sec:examples}}

\hypertarget{extension-added-in-the-r-package-tourr}{%
\section{\texorpdfstring{Extension added in the R package
\texttt{tourr}}{Extension added in the R package tourr}}\label{extension-added-in-the-r-package-tourr}}

\hypertarget{what-would-be-desirable-for-implementations-in-r}{%
\section{What would be desirable for implementations in
R?}\label{what-would-be-desirable-for-implementations-in-r}}

\hypertarget{sec:discussion}{%
\section{Discussion}\label{sec:discussion}}

\hypertarget{acknowledgements}{%
\section*{Acknowledgements}\label{acknowledgements}}
\addcontentsline{toc}{section}{Acknowledgements}

The authors gratefully acknowledge the support of the Australian
Research Council. The paper was written in \texttt{rmarkdown}
\citep{rmarkdown} using \texttt{knitr} \citep{knitr}.

\hypertarget{supplementary-material}{%
\section*{Supplementary material}\label{supplementary-material}}
\addcontentsline{toc}{section}{Supplementary material}

The source material and animated gifs for this paper are available at

\bibliographystyle{tfcad}
\bibliography{biblio.bib}





\end{document}
