---
title: |
  A new simplified manual tour, with examples in mathematica and R
type: Short Technical Note
author:
  - name: Alex Aumann
    affil: a
    email: aaum0002@student.monash.edu
  - name: German Valencia
    affil: a
    email: german.valencia@monash.edu
  - name: Ursula Laa
    affil: b
    email: ursula.laa@boku.ac.at
  - name: Dianne Cook
    affil: c
    email: dicook@monash.edu
affiliation:
  - num: a
    address: |
      School of Physics and Astronomy, Monash University
  - num: b
    address: |
      Institute of Statistics, University of Natural Resources and Life Sciences, Vienna
  - num: b
    address: |
      Department of Econometrics and Business Statistics, Monash University
bibliography: biblio.bib
geometry: margin=2.5cm
abstract: |
  Something here
keywords: |
  data visualisation; grand tour; statistical computing; statistical graphics; multivariate data; dynamic graphics
header-includes: |
  \usepackage{hyperref}
  \usepackage[utf8]{inputenc}
  \def\tightlist{}
  \usepackage{setspace}
  \usepackage{graphicx}
output: rticles::tf_article
keep_tex: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, 
  message = FALSE,
  warning = FALSE)
```

```{r libraries}
# Load libraries
library(tourr)
library(plotrix)
```

<!-- \doublespacing-->
# Introduction

<!-- Background -->
From a statistical perspective it is rare to have data that are strictly 3D, and so unlike in most computer graphics applications, the more useful methods for data analysis show projections from an arbitrary dimensional space. These are dynamic data visualizations methods and are collected under the term *tours*. Tours involve views of high-dimensional ($p$) data in low-dimensional ($d$) projections. In his original paper on the grand tour, @As85 provided several algorithms for tour paths that could theoretically show the viewer the data *from all sides*. Prior to Asimov's work, there were numerous preparatory developments including @tukey's PRIM-9. PRIM-9 had user-controlled rotations on coordinate axes, allowing one to manually tour through low-dimensional projections. It is impractical to impossible to steer through all possible projections, unlike Asimov's tours which allows one to quickly see many, many different projections. After Asimov there have been many, many tour developments, as summarized in @lee2021. 

<!-- Manual tours -->
One such direction of work develops the ideas from PRIM-9, to provide manual control of a tour. @cook_manual_1997 describes controls for 1D (or 2D) projections, in a 2D (or 3D) manipulation space, allowing the user to select any variable axis, and rotate it into or out of or around the projection through horizontal, vertical, oblique, radial or angular changes in value. @spyrison_spinifex_2020 refines this algorithm and implements them to generate animations. 

<!-- Purpose -->
Manual controls are especially useful for assessing sensitivity of structure to particular elements of the projection. There are many places where it is useful. In exploratory data analysis, where one sees clusters in a projection, can some variables be removed from the projection without affecting the clustering. For interpreting models, one can reduce or increase a variable's contribution to examine the variable importance. These controls can also be used to interactively generate facetted plots [@XXX], or spatiotemporal glyphmaps [@XXX]. Having the user interact with a projection is extremely valuable for understanding high-dimensional data. However, these algorithms have two problems: (1) the pre-processing of creating a manipulation space overly complicates the algorithm, (2) extending to higher dimensional control is difficult. 

Through experiments with the relatively new interactive graphics capabilities in mathematica(?), we have realized that there is a simpler approach, which is more direct, and extensible for generating user interaction. This paper explains this, and is organized as follows. The next section describes the new algorithm for manual control. This is followed by details on implementation. The applications section illustrate how these can be used. 

# Manual tour {#sec:method}

An orthonormal basis ($A_{p\times d}$) and a variable id ($m \in \{1, ..., p\}$) to control are provided to initialise a manual tour. A method to update the values of the component of the controlled variable $V_m$ is needed. 

## Background

In the original work, the method for updating component values, for a 2D projection, was built trackball controls in 3D. A 3D manipulation space is created, as illustrated in Figure \ref{manipspace}, where the controlled variable has full range of motion from -1 to 1. Movements of a cursor are recorded and converted into changes in the values of $V_m$ to change it's values in the displayed 2D projection. Movement could also be constrained to be only in horizontal, vertical, radial or angular motions. 

\begin{figure*}[ht]
\centerline{\includegraphics[width=0.8\textwidth]{figures/manip_space.pdf}}
\caption{Original contruction of the manual tour designed for 2D projections and created a 3D space from which to utilise track ball controls to change it's contribution. (Figure 3 from Cook and Buja (1997).)}
\label{manipspace}
\end{figure*}

## New simpler definition

The new approach emerged from experiments in mathematica. The components corresponding to $V_m$ are directly controlled by cursor movement, which updates row $m$ of $A$. The updated matrix is then orthonormalised. 

### Algorithm 1

1. Provide $A$, and $m$. (Note that $m$ could also be automatically chosen as the component that is closest to the cursor position.)
2. Change values in row $m$, giving $A^*$. A large change in these values would correspond to making a large jump from the current projection. Small changes would correspond to tracking a cursor, making small jumps from the current projection.
3. Orthonormalise $A^*$, using Gram-Schmidt. For $d=2$, and $A^* = \left[ {\boldmath a}_{.1}~{\boldmath a}_{.2}\right]$, the steps are:

    i. Normalise ${\boldmath a}_{.1}$, and ${\boldmath a}_{.2}$.
    ii. ${\boldmath a}^*_{.2} = {\boldmath a}_{.2} - {\boldmath a}_{.1}^T{\boldmath a}_{.2}{\boldmath a}_{.1}$.
    iii. Normalise ${\boldmath a}^*_{.2}$.

This algorithm will produce the changes to a projection as illustrated in Figure \ref{fig:manualsequence} (top row). The controlled variable, $V_m$, corresponds to the black line, and sequential changes to row $m$ of $A$ can be seen to roughly follow a specified position (orange dot). Changes in the other components happen as a result of the orthonormalisation, but are uncontrolled. 

### Algorithm 2

The problem with Algorithm 1 is that the precise values for $V_m$ cannot be specified because the orthonormalisation wil change them. This modification will maintain the components of $V_m$ precisely (Figure \ref{fig:manualsequence} (bottom row)). The algorithm is as follows:

1. Provide $A$, and $m$.
2. Change values in row $m$, giving $A^*$.
3. Store row $m$ separately, and zero the values of row $m$ in $A^*$, giving $A^{*0}$. 
4. Orthonormalise $A^{*0}$, using Gram-Schmidt.
5. Replace row $m$ with the original values, giving $A^{**}$. 
6. For $d=2$, adjust the values of ${\boldmath a}^{**}_{.2}$ using 

$$a^{**}_{j2}+\frac{a_{m1}a_{m2}}{p-1}, j=1, ..., p, j\neq m$$.

which ensures that 

$$\sum_{j=1, j\neq m}^p a^{**}_{j1}a^{**}_{j2} + a_{m1}a_{m2} = 0$$.

If $d>2$ the process would be sequentially repeated in the same manner that Gram-Schmidt is applied sequentially to orthormalise the columns of a matrix. If $d=1$ no orthonormalisation is needed, and the projection vector would simply need to be normalised after each adjustment. 

<!-- Need to think about how the values for selected variable are made exact, that is constrained orthonormalisation.

Need to think about checks, and error catching, maybe in implementation section. If selected variable has 0 coefficient, will that generate an orthonormalisation error?-->

```{r manualsequence, outwidth="80%", width=12, height=5, fig.cap="Sequence of projections where contribution of one variable is controlled (black) is changed: (top) unconstrained orthonormalisation, (bottom) constrained as specified. The dot (orange) indicates the chosen values for the controlled variable. For the constrained orthonormalisation it can be seen to precisely match the axis, but not so for the unconstrained orthonormalisation."}
source("../code/plot_basis.R")
source("../code/linear_alg.R")

# Base plot set up
plot.new()
par(pty="s", xaxt="n", yaxt="n", bty="n",
      omi=c(0,0,0,0), mar=c(0,0,0,0),
    mfrow=c(2,4))

# Create manual tour example
p <- 4
d <- 2
set.seed(24)
A <- matrix(runif(p*d, min=-1), ncol=d, byrow=TRUE)
colnames(A) <- c("P1", "P2")
rownames(A) <- paste0("V", 1:p)
A <- tourr::orthonormalise(A)
  
# Now set a new position
vchange <- 3
eps <- 0.1
plot_basis(A, vchange, vcol="black")

# Iterate and save images
# Unconstrained orthonormalisation
Anew <- A
for (i in 1:3) {
  Anew[vchange,] <- A[vchange,]*(1-i*eps)
  exact <- Anew[vchange,]
  Anew <- tourr::orthonormalise(Anew)
  plot_basis(Anew, vchange, vcol="black")
  points(exact[1], exact[2], pch=16, col="orange")
}

# Iterate and save images
# Constrained orthonormalisation
Anew <- A
plot_basis(A, vchange, vcol="black")
for (i in 1:3) {
  Anew[vchange,] <- A[vchange,]*(1-i*eps)
  exact <- Anew[vchange,]
  Anew <- orthonormalise_frozen(Anew, vchange)
  plot_basis(Anew, vchange, vcol="black")
  points(exact[1], exact[2], pch=16, col="orange")
}
```




# Implementation {#sec:implementation}



# Applications {#sec:examples}


# Discussion {#sec:discussion}



# Acknowledgements {-}

The authors gratefully acknowledge the support of the Australian Research Council. The paper was written in `rmarkdown` [@rmarkdown] using `knitr` [@knitr]. 

# Supplementary material {-}

The source material and animated gifs for this paper are available at 
